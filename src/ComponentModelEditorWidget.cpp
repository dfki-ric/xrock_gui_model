#include "ComponentModelEditorWidget.hpp"
#include "XRockGUI.hpp"
#include "ConfigureDialog.hpp"
#include "ConfigMapHelper.hpp"

#include <QVBoxLayout>
#include <QLabel>
#include <QGridLayout>
#include <QPushButton>
#include <QRegExp>
#include <QTextEdit>
#include <QFileDialog>
#include <QDateTime>
#include <QMessageBox>
#include <QDebug>
#include <bagel_gui/BagelGui.hpp>
#include <bagel_gui/BagelModel.hpp>
#include <mars/utils/misc.h>
#include <QDesktopServices>
#include <xtypes/ComponentModel.hpp>

using namespace configmaps;

namespace xrock_gui_model
{

    ComponentModelEditorWidget::ComponentModelEditorWidget(mars::cfg_manager::CFGManagerInterface *cfg,
                             bagel_gui::BagelGui *bagelGui, XRockGUI *xrockGui,
                             QWidget *parent) : mars::main_gui::BaseWidget(parent, cfg, "ComponentModelEditorWidget"), bagelGui(bagelGui),
                                                xrockGui(xrockGui)
    {
        try
        {
            ignoreUpdate = false;
            QGridLayout *layout = new QGridLayout();
            QVBoxLayout *vLayout = new QVBoxLayout();
            edition = "";
            size_t i = 0;
            // 20221107 MS: Why does this widget set a model path?
            auto cm = std::make_shared<ComponentModel>();
            const nl::json props = cm->get_properties();
            for (auto it = props.begin(); it != props.end(); ++it)
            {
                if (it->is_null())
                    continue; // skip for now..

                const QString key = QString::fromStdString(it.key());
                const QString value = QString::fromStdString(it.value());
                QLabel *label = new QLabel(key);
                layout->addWidget(label, i, 0);
                const auto allowed_values = cm->get_allowed_property_values(key.toStdString());
                if (allowed_values.size() > 0)
                {
                    // if property has some allowed values, its a combobox
                    QComboBox *combobox = new QComboBox();
                    for (const auto &allowed : allowed_values)
                        combobox->addItem(QString::fromStdString(allowed));
                    layout->addWidget(combobox, i++, 1);
                    connect(combobox, SIGNAL(textChanged(const QString &)), this, SLOT(updateModel()));
                    widgets[label] = combobox;
                }
                else
                {
                    // if property has no allowed values, its a qlineedit
                    QLineEdit *linedit = new QLineEdit();
                    layout->addWidget(linedit, i++, 1);
                    connect(linedit, SIGNAL(textChanged(const QString &)), this, SLOT(updateModel()));
                    widgets[label] = linedit;
                }
            }

            // 20221107 MS: What are annotations?
            //l = new QLabel("annotations");
            //layout->addWidget(l, i, 0);
            //annotations = new QTextEdit();
            //layout->addWidget(annotations, i++, 1);
            //dataStatusLabel = new QLabel();
            //dataStatusLabel->setText("valid Yaml syntax");
            //dataStatusLabel->setAlignment(Qt::AlignCenter);
            //if (annotations)
            //{
            //    dataStatusLabel->setStyleSheet("QLabel { background-color: #128260; color: white; }");
            //    layout->addWidget(dataStatusLabel, i++, 1);
            //    connect(annotations, SIGNAL(textChanged()), this, SLOT(validateYamlSyntax()));
            //}

            QLabel *l = new QLabel("interfaces");
            layout->addWidget(l, i, 0);
            interfaces = new QTextEdit();
            interfaces->setReadOnly(true);
            connect(interfaces, SIGNAL(textChanged()), this, SLOT(updateModel()));
            layout->addWidget(interfaces, i++, 1);
            vLayout->addLayout(layout);

            vLayout->addStretch();

            // 20221107 MS: These have to be generated by the allowed domain values and should be done more generic
            QGridLayout *gridLayout = new QGridLayout();
            l = new QLabel("Layout:");
            gridLayout->addWidget(l, 0, 0);
            i = 0;
            for (const auto allowed : cm->get_allowed_property_values("domain"))
            {
                QCheckBox *check = new QCheckBox(QString::fromStdString(allowed));
                check->setChecked(true);
                connect(check, SIGNAL(stateChanged(int)), this, SLOT(setViewFilter(int)));
                gridLayout->addWidget(check, i / 2, i % 2 + 1);
                layoutCheckBoxes[allowed] = check;
                i++;
            }
            vLayout->addLayout(gridLayout);
            layouts = new QListWidget();
            vLayout->addWidget(layouts);
            connect(layouts, SIGNAL(clicked(const QModelIndex &)),
                    this, SLOT(layoutsClicked(const QModelIndex &)));
            layouts->addItem("overview");
            QHBoxLayout *hLayout = new QHBoxLayout();
            layoutName = new QLineEdit("new layout");
            hLayout->addWidget(layoutName);
            QPushButton *b = new QPushButton("add/remove");
            connect(b, SIGNAL(clicked()), this, SLOT(addRemoveLayout()));
            hLayout->addWidget(b);
            vLayout->addLayout(hLayout);


            // 20221107 MS: Removed buttons in favor of the XRock Toolbar
            setLayout(vLayout);
            currentLayout = "";
            this->clear();

            // 20221107 MS: What is the XRock config filter?
            //xrockConfigFilter.push_back("activity");
            //xrockConfigFilter.push_back("state");
            //xrockConfigFilter.push_back("config_names");
            //xrockConfigFilter.push_back("parentName");

        }
        catch (const std::exception &e)
        {
            std::stringstream ss;
            ss << "Exception thrown: " << e.what() << "\tAt " << __FILE__ << ':' << __LINE__ << '\n'
               << "\tAt " << __PRETTY_FUNCTION__ << '\n';
            QMessageBox::warning(nullptr, "Warning", QString::fromStdString(ss.str()), QMessageBox::Ok);
        }
    }

    ComponentModelEditorWidget::~ComponentModelEditorWidget(void)
    {
    }

    void ComponentModelEditorWidget::deinit(void)
    {
        // 20221107 MS: Why does this widget set a model path?
        //cfg->setPropertyValue("XRockGUI", "modelPath", "value", modelPath);
    }

    void ComponentModelEditorWidget::currentModelChanged(bagel_gui::ModelInterface *model)
    {
        ComponentModelInterface* newModel = dynamic_cast<ComponentModelInterface *>(model);
        if (!newModel) return;
        currentModel = nullptr;
        // TODO: Update all fields with the info given by the map. We should NOT trigger textChanged() though!
        auto info = newModel->getModelInfo();
        name->setText(QString::fromStdString(info["name"]));
        // Set the newModel to be the current model
        // which will also allow updates to the model via updateModel()
        currentModel = newModel;
    }

    void ComponentModelEditorWidget::updateModel()
    {
        if (!currentModel) return;
        ConfigMap updatedMap(currentModel->getModelInfo());
        updatedMap["name"] = name->text().toStdString();
        // TODO: Read out the other fields and update the model properties of the currentModel
        currentModel->setModelInfo(updatedMap);
    }

    void ComponentModelEditorWidget::setViewFilter(int v)
    {
        for (const auto& [label, checkbox] : layoutCheckBoxes)
        {
            bagelGui->setViewFilter(label, checkbox->isChecked());
        }
    }

    void ComponentModelEditorWidget::setEdition(const std::string &domain)
    {
        this->edition = domain;
        for (auto it : layoutCheckBoxes)
        {
            if (it.first == domain)
            {
                it.second->setChecked(true);
            }
            else
            {
                it.second->setChecked(false);
            }
        }
        handleEditionLayout();
    }

    void ComponentModelEditorWidget::layoutsClicked(const QModelIndex &index)
    {

        try
        {
            QVariant v = layouts->model()->data(index, 0);
            if (v.isValid())
            {
                std::string layout = v.toString().toStdString();
                updateCurrentLayout();
                currentLayout = layout;
                layout += ".yml";
                layoutName->setText(currentLayout.c_str());

                bagelGui->loadLayout(layout);
                bagelGui->applyLayout(layoutMap[currentLayout]);
            }
        }
        catch (const std::exception &e)
        {
            std::stringstream ss;
            ss << "Exception thrown: " << e.what() << "\tAt " << __FILE__ << ':' << __LINE__ << '\n'
               << "\tAt " << __PRETTY_FUNCTION__ << '\n';
            QMessageBox::warning(nullptr, "Warning", QString::fromStdString(ss.str()), QMessageBox::Ok);
        }
    }

    void ComponentModelEditorWidget::addRemoveLayout()
    {
        try
        {
            std::string name = layoutName->text().toStdString();
            for (int i = 0; i < layouts->count(); ++i)
            {
                QVariant v = layouts->item(i)->data(0);
                if (v.isValid())
                {
                    std::string layout = v.toString().toStdString();
                    if (layout == name)
                    {
                        QListWidgetItem *item = layouts->item(i);
                        delete item;
                        layoutMap.erase(name);
                        if (layouts->count() > 0)
                        {
                            layouts->setCurrentItem(layouts->item(0));
                            currentLayout = layouts->item(0)->data(0).toString().toStdString();
                            layoutName->setText(currentLayout.c_str());
                            bagelGui->applyLayout(layoutMap[currentLayout]);
                        }
                        else
                        {
                            currentLayout = "";
                            layouts->setCurrentItem(0);
                        }
                        updateModel();
                        return;
                    }
                }
            }
            updateCurrentLayout();
            ConfigMap layout;
            layouts->addItem(name.c_str());
            layouts->setCurrentItem(layouts->item(layouts->count() - 1));
            currentLayout = name;
            updateCurrentLayout();
            updateModel();
        }

        catch (const std::exception &e)
        {
            std::stringstream ss;
            ss << "Exception thrown: " << e.what() << "\tAt " << __FILE__ << ':' << __LINE__ << '\n'
               << "\tAt " << __PRETTY_FUNCTION__ << '\n';
            QMessageBox::warning(nullptr, "Warning", QString::fromStdString(ss.str()), QMessageBox::Ok);
        }
    }

    void ComponentModelEditorWidget::updateCurrentLayout()
    {
        if (!currentLayout.empty())
        {
            ConfigMap layout = bagelGui->getLayout();
            layoutMap[currentLayout] = layout;
        }
    }

    void ComponentModelEditorWidget::handleEditionLayout()
    {
        try
        {
            // if possible set the layout depending on the edition
            if (!edition.empty())
            {
                bool found = false;
                if (layoutMap.size())
                {
                    for (auto it : layoutMap)
                    {
                        if (it.first == edition)
                        {
                            found = true;
                            currentLayout = edition;
                            bagelGui->applyLayout(it.second);
                            for (int i = 0; i < layouts->count(); ++i)
                            {
                                QVariant v = layouts->item(i)->data(0);
                                if (v.isValid())
                                {
                                    std::string layout = v.toString().toStdString();
                                    if (layout == edition)
                                    {
                                        layouts->setCurrentItem(layouts->item(i));
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
                if (!found)
                {
                    // create a layout for the used edition
                    updateCurrentLayout();
                    layouts->addItem(edition.c_str());
                    layouts->setCurrentItem(layouts->item(layouts->count() - 1));
                    currentLayout = edition;
                    updateCurrentLayout();
                    updateModel();
                }
            }
        }
        catch (const std::exception &e)
        {
            std::stringstream ss;
            ss << "Exception thrown: " << e.what() << "\tAt " << __FILE__ << ':' << __LINE__ << '\n'
               << "\tAt " << __PRETTY_FUNCTION__ << '\n';
            QMessageBox::warning(nullptr, "Warning", QString::fromStdString(ss.str()), QMessageBox::Ok);
        }
    }


    void ComponentModelEditorWidget::clear()
    {
        ignoreUpdate = true;
        edition = "";
        name->clear();
        type->clear();
        maturity->clear();
        projectName->clear();
        designedBy->clear();
        version->clear();
        //annotations->clear();
        interfaces->clear();
        layouts->clear();
        layoutMap = ConfigMap();
        ignoreUpdate = false;
    }


    void ComponentModelEditorWidget::openUrl(const QUrl &link)
    {
        QDesktopServices::openUrl(link);
    }

    void ComponentModelEditorWidget::validateYamlSyntax()
    {
        const std::string data_text = annotations->toPlainText().toStdString();
        if (data_text.empty())
            return;
        try
        {
            ConfigMap tmpMap = ConfigMap::fromYamlString(data_text);
            dataStatusLabel->setText("valid Yaml syntax");
            dataStatusLabel->setStyleSheet("QLabel { background-color: #128260; color: white;}");
        }
        catch (...)
        {
            dataStatusLabel->setText("invalid Yaml syntax");
            dataStatusLabel->setStyleSheet("QLabel { background-color: red; color: white;}");
        }
    }

} // end of namespace xrock_gui_model
